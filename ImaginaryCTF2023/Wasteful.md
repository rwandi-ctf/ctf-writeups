# Wasteful

category: crypto

```py
from Crypto.Util.number import *
from math import gcd


def keygen(sz):
    p = getPrime(sz // 2)
    q = getPrime(sz // 2)
    n = p * q
    phi = (p - 1) * (q - 1)
    e_fast = getPrime(sz // 2)
    # to make encryption more time consuming :P
    e_slow = e_fast + getPrime(sz // 3) * phi
    d = pow(e_fast, -1, phi)
    return (n, e_slow), (n, e_fast), (n, d)


def encrypt(pub, m):
    n, e = pub
    return pow(m, e, n)


def decrypt(priv, c):
    n, d = priv
    return pow(c, d, n)


pub, pub_fast, priv = keygen(2048)
m = bytes_to_long(open("flag.txt", "rb").read().strip())
c = encrypt(pub, m)
assert c == encrypt(pub_fast, m)
assert decrypt(priv, c) == m
print(f"{pub = }")
print(f"{c = }")
```

so instead of normal e of 65537 they use a getprime(1028) e and then also proceed to add phi * another 600 bit prime

the idea is that usually prime e is fine

but by adding this phi thingy it leaks some info about phi so u can use that to get some bits of p and q:

$$e_\text{slow} = e_\text{fast} + p_3 \phi$$

due to the size of $\phi$ compared to $e_\text{fast}$ and how $\phi \approx n$,

$$p_3 = \lceil \frac{e_\text{slow}}{n} \rceil$$

$$\frac{e_\text{slow}}{p_3} \approx \phi$$

off by only a 2048/6 bit number. so, we can use this to approximate p and q using n and then coppersmith ya

$$\frac{e_\text{slow}}{p_3} \approx n+1 - (p+q)$$

solve quadratic with approx for p+q and pq and profit

$$p((p+q)-p)=n$$

```py
# sage
from Crypto.Util.number import *
pub = (13922840822259331816327061476419085409003512519528232469661604921423111313933598569871108546042864180459201549111178812056125732062953204575105829153985440916358190133642640001059768522480269302460718708597523393249631888987925111597599833550446912844403320258488415701628616610291446078064678789122886626285576964983117608034972639529880315364530395658464093479171544352975507100901794069628879853771787404835325718642690170628943504486705897282590391844395048189949020318348859452241379637822658476872641393738097989171169214581791719140741349554748016829670973465416125341357284757048506380319235703137899963208097, 277280553454648256942834244379334472844168843473349557354045626945887508188843789771287658693103957086560979814144224475018152887866998026452048010146805033029525535857427508882228600591838528622357772029813779190474001956391284442790327418967008241712383374750163158501752035607501218757269377329115862935993211034408859090869371053922670217394364484435238584857739198196990517123089953446738914179515819217861804510588560805960014326909359351025582398395246863003472699126965102937701727970546875134667199496557865907051073237849103589853403297723219825816214258909806838856777367332603146213417602038287539276024671910161582026600672105045278321812944891449538504092047724097803562730455612681768718159973804451251572816656604960574129566605495957657313103014678987914865218770999608008584731005908772508291497450420251)
ct = 3829822460565637897613746990073994763941184171034737019836828390881076647859928468862763977005814025279072259387758773244151849201650347661717265009919615554395232777636705330792559486048004076300537706604078026741727734943374711480077394341022197696120902084993991738576670236710557122356593411988288326114827264936321401579532665129353852827951354347055111972043781820183887400365339563091888343224947709711699474542183525971689156145628294192147447087789859929759168015997297169275809161690938900939934830602427271340102001253593076013316161869089892572516396348368906753304918487695981844135741146949836634949417
n,e_slow = pub
p3 = e_slow//n+1
phi = e_slow//p3
e_fast = e_slow%p3

a = 1
b = (e_slow - p3*(n+1))//p3
c = n

p_approx, q_approx = (-b + int(floor((b**2-4*a*c)^(1/2))))//(2*a), (-b - int(floor((b**2-4*a*c)^(1/2))))//(2*a)
P.<x> = Zmod(n)[]
f = x + p_approx
p = int(f.small_roots(beta=0.49)[0]+p_approx)
q = n//p
phi = (p-1)*(q-1)
d = pow(e_slow, -1, phi)
long_to_bytes(pow(ct, d, n))
```

`ictf{just_an_obligatory_coppersmith_challenge}`