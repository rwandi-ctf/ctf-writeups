# Tan

category: crypto

32 solves

```py
print(tan(int.from_bytes(open("flag.txt", "rb").read().strip(), "big")).n(1024))
# -0.7578486465144361653056740883647981074157721568235263947812770328593706155446273431983003083023944193451634501133844062222318380912228469321984711771640337084400211818130699382144693337133198331117688092846455855532799303682791981067718891947573941091671581719597626862194794682042719495503282817868258547714
```

we just get tan of a number to 1024 bits of decimal places

heeheheee LLL to find a

$$\arctan(\tan(\text{flag}))+n \cdot 2 \pi \approx \text{integer}$$

```py
# sage
tanned = -0.7578486465144361653056740883647981074157721568235263947812770328593706155446273431983003083023944193451634501133844062222318380912228469321984711771640337084400211818130699382144693337133198331117688092846455855532799303682791981067718891947573941091671581719597626862194794682042719495503282817868258547714
W = diagonal_matrix([1, 10^10, 1/10^100, 1])
L = Matrix([[1, 0, 0, round(2 * pi * 10^306)],
            [0, 1, 0, round(arctan(tanned).n(digits=306) * 10^306)],
           [0, 0, 1, -10^306],
           [0,0,0,0]])
sol = (L*W).LLL()/W
for i in sol:
    #print(i)
    if i[-3]==1 and abs(i[-1])<10^900:
        print(i)
        print(long_to_bytes(int(i[2])))
        maybe = (i[0] * 2 * pi + arctan(tanned)).n(1024)
        print(maybe.str(no_sci=2))
```

`ictf{can_you_break_sin_or_cos_too?}`