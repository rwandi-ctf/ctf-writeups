# Poly Fractions

category: crypto

author: `hellopir2`

`main.py`:

```py
#!/usr/local/bin/python
import random
import math
from flag import flag, text

a = 1
b = random.randint(-10, 10)
b2 = random.randint(-10, 10)
numcoefficients = [a, b]
denomcoefficients = [a, b2]
query = 0
for i in flag:
    sign = random.randint(0, 1)
    if sign == 0:
        sign -= 1
    numcoefficients.append(sign * int(i))
for i in text:
    sign = random.randint(0, 1)
    if sign == 0:
        sign -= 1
    denomcoefficients.append(sign * int(i))
numcoefficients.reverse()
denomcoefficients.reverse()
while True:
    try:
        query += 1
        if query > 500:
            print("exceeded query limit!")
            exit(0)
        numcoefficients[-2] = random.randint(-10, 10)
        denomcoefficients[-2] = random.randint(-10, 10)
        x = int(input("x: "))
        if -99 <= x <= 99:
            x1 = 1
            numerator = 0
            for i in numcoefficients:
                numerator += i * x1
                x1 *= x
            x2 = 1
            denominator = 0
            for i in denomcoefficients:
                denominator += i * x2
                x2 *= x
            gcd = math.gcd(numerator, denominator)
            print(str(numerator//gcd) + "/" + str(denominator//gcd))
        else:
            print("input must be at most 2 digits")
    except:
        print("invalid input")
        exit(0)
```

This code defines two polynomials:

$$f(x) = x^m + r_1x^{m-1} \pm F_1x^{m-2} \pm F_2x^{m-3}...\pm F_{-2}x \pm F_{-1}$$
$$g(x) = x^n + r_2x^{n-1} \pm T_1x^{n-2} \pm T_2x^{n-3}... \pm T_{-2}x \pm T_{-1}$$

where $F$ is the flag and $T$ is the text (not given), and $r_1$ and $r_2$ are independent random numbers generated by `randint(-10,10)` which are refreshed every iteration. $\pm$ here represents the random sign given to each flag and text coefficient, but is only generated once and remains the same throughout iterations.

Then, they ask for an input $-99 \le x \le 99$ and returns the most simplified fraction of

$$\frac{f(x)}{g(x)}$$

499 times.

# $r_1, r_2$
The first thing to consider is how $r_1, r_2$ are the coefficients of the second most significant monomial in both polynomials, and without figuring out which function values have which $r$, we would not be able to distinguish the flag from this value.

Additionally, we have the issue of the fraction being simplified so we don't know which numerators correspond to the original values of $f(x)$.

Well, surely $f(x)$ and $g(x)$ don't always have a common factor, so if we just spam values we would get some cases where they aren't reduced. But how can we tell when they aren't reduced?

We can take advantage of $r_1$ and $r_2$. If we query 499 times, every value from -10 to 10 is bound to come up at least once in $r_1$. So, if we can find 21 distinct values of numerator that are an arithmetic sequence with difference $x^{m-1}$, we would know we have found the nonreduced $f(x)$ values.

If they were reduced by $k$ instead, the difference would then be $\frac{x^{m-1}}{k}$.

But wait. We don't even have $m$? Well, we can just look at every difference between two numerator results, and take the maximum $x^{m-1}$ that divides into any of them.

```py
nd=[]
conn = remote("amt.rs", 31312)
for _ in tqdm(range(499)): conn.sendline("99")
rec=[]
for _ in tqdm(range(499)): rec.append(conn.recvline())

nds = [tuple(map(int, i.decode()[3:-1].split("/"))) for i in rec]
ns = [i[0] for i in nds]
diffs = set()
for i in range(10):
    for j in range(i+1, 10):
        if abs(ns[i]-ns[j])%99==0:
            exp = 0
            while abs(ns[i]-ns[j])%(99**exp)==0: exp+=1
            diffs.add(exp-1)
max(diffs)
```

This gives a value of $133$, so now we know $m = 134$.

Now, we can look for the set of values with differences $99^{133}$:

```py
sets = []
for i in tqdm(ns):
    found=False
    for rand in range(-20, 20):
        for sett in sets:
            if i + rand * 99**133 in sett:
                sett.add(i)
                found=True
                break
        if found: break
    if not found: sets.append(set([i]))
[len(sett) for sett in sets]
```

gives `[21, 10, 2, 4, 4, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 1]`. This means that the first set, with length 21, is the set we want. Even better, by sorting it and taking the 11th value, we know thats the one where $r_1=0$. Now, we can get the flag part of the polynomial by also subtracting $x^m$, giving

$$\text{}\pm F_1x^{132} \pm F_2x^{131}...\pm F_{132}x \pm F_{133}$$

But even from this value, how can we recover the flag? It's not exactly trivial.

# $F$

The problem is that the range of possible values of $\pm F_i$ is too large to be distinguished from each other consistently.

For example,

$$100 \cdot 99^{i+1} - 99 \cdot 99^i=98 \cdot 99^{i+1} + 99 \cdot 99^i$$

making the two letter sequences "dc" and "bc" potentially indistinguishable.

Particularly, if

$$2 \text{max}(F_i) < x$$

then we can distinguish the letters by treating the number as in "base x" but with allowing negative digits.

Unsure what to do here, I tried employing LLL to recover the flag, but as expected, it yielded working values that did not necessarily correspond to the flag, as well as being difficult to conform to the range of printable character's `ord`s.

Then while in the shower, I came up with a genius idea: submit $x=-99$ as well. Then, by taking the difference/sum of the values, I can obtain a polynomial of alternating values.

Let $s_i$ replace $\pm$.

$$s_1 F_1(+99)^{132} +s_2 F_2(+99)^{131}+...+s_{132} F_{132}(+99) +s_{133} F_{133}$$
$$s_1 F_1(-99)^{132} +s_2 F_2(-99)^{131}+...+s_{132} F_{132}(-99) +s_{133} F_{133}$$

Summing and dividing by 2 obtains the even powers:

$$s_1 F_1(99)^{132} +s_3 F_3(99)^{130}+...+s_{131} F_{131}(99)^2 +s_{133} F_{133}$$

Taking the difference and dividing by 2 obtains the odd powers:

$$s_2 F_2(99)^{131} +s_4 F_4(99)^{129}+...+s_{130} F_{130}(99)^3 +s_{132} F_{132}(99)$$

And with this, since the effective $x$ here is $99^2$, we now can extract the flag characters! So we do the same thing as before but do it twice for $99$ and $-99$.

```py
nd=[]
conn = remote("amt.rs", 31312)
for _ in tqdm(range(250)): conn.sendline("99")
for _ in tqdm(range(249)): conn.sendline("-99")
rec=[]
for _ in tqdm(range(499)): rec.append(conn.recvline("99"))
nds = [tuple(map(int, i.decode()[3:-1].split("/"))) for i in rec]
posns = [i[0] for i in nds][:250]
negns = [i[0] for i in nds][250:]
possets = []
negsets = []
for i in tqdm(posns):
    found=False
    for rand in range(-20, 20):
        for sett in possets:
            if i + rand * 99**133 in sett:
                sett.add(i)
                found=True
                break
        if found: break
    if not found: possets.append(set([i]))
for i in tqdm(negns):
    found=False
    for rand in range(-20, 20):
        for sett in negsets:
            if i + rand * 99**133 in sett:
                sett.add(i)
                found=True
                break
        if found: break
    if not found: negsets.append(set([i]))
posi = [len(sett) for sett in possets].index(21)
negi = [len(sett) for sett in negsets].index(21)
pos = sorted(possets[posi])[10] - 99**134
neg = sorted(negsets[negi])[10] - 99**134
odd = (pos+neg)//2
even = (pos-neg)//2
even//=99
oddb = []
evenb = []
while odd!=0:
    rem = odd%(99**2)
    if rem>256:
        rem = 99**2-rem
        odd+=rem
    else:
        odd-=rem
    oddb.append(rem)
    odd//=99**2
while even!=0:
    rem = even%(99**2)
    if rem>256:
        rem = 99**2-rem
        even+=rem
    else:
        even-=rem
    evenb.append(rem)
    even//=99**2
oddb.reverse()
evenb.reverse()
flag=[]
for i in range(66):
    flag.append(oddb[i])
    flag.append(evenb[i])
flag.append(oddb[66])
print(bytes(flag))
```

which prints `some other text to act as a placeholder so the flagcrib doesnt give anything away flag: amateursCTF{c001-polynOmiaL_iNt3rp0La7ioN&&&}`.