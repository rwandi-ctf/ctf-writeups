# You get extra information 1

category: crypto

author: `hellopir2`

we are given a `main.py`:

```py
from Crypto.Util.number import *
from flag import flag

p = getPrime(512)
q = getPrime(512)
n = p*q
p = p + q
e = 0x10001

extra_information = p + q
ptxt = bytes_to_long(flag)
c = pow(ptxt, e, n)

with open('output.txt', 'w') as f:
    f.write(f"n: {n}\nc: {c}\ne: {e}\nextra_information: {extra_information}")
```

and its `output.txt`:

```
n: 83790217241770949930785127822292134633736157973099853931383028198485119939022553589863171712515159590920355561620948287649289302675837892832944404211978967792836179441682795846147312001618564075776280810972021418434978269714364099297666710830717154344277019791039237445921454207967552782769647647208575607201
c: 55170985485931992412061493588380213138061989158987480264288581679930785576529127257790549531229734149688212171710561151529495719876972293968746590202214939126736042529012383384602168155329599794302309463019364103314820346709676184132071708770466649702573831970710420398772142142828226424536566463017178086577
e: 65537
extra_information: 26565552874478429895594150715835574472819014534271940714512961970223616824812349678207505829777946867252164956116701692701674023296773659395833735044077013
```

So, this is standard RSA on the flag, with public key $n=pq$. But we also have *extra information*!! which is $p + 2q$ here.

Given $n=pq$ and $p+2q$, how can we find $p$ and $q$?

Well, given a sum and product, we can tell this is a bounding problem. Essentially, increasing $q$ by 1 would decrease $p$ by 2, and you could keep comparing the value of $pq$ with $n$ to binary search into the true values of $p$ and $q$. Of course, we dont have to implement this, z3!

```py
import z3
p = z3.Int("p")
q = z3.Int("q")
z3.solve(p*q==83790217241770949930785127822292134633736157973099853931383028198485119939022553589863171712515159590920355561620948287649289302675837892832944404211978967792836179441682795846147312001618564075776280810972021418434978269714364099297666710830717154344277019791039237445921454207967552782769647647208575607201,
         p+2*q==26565552874478429895594150715835574472819014534271940714512961970223616824812349678207505829777946867252164956116701692701674023296773659395833735044077013,
         2**511<=p,
         2**511<=q,
         p<2**512,
         q<2**512
         )
```

returns 
```
[q = 8128979845892982561867353232387733688040820165501281055994560204992985831326225951788922087412585314864187432126945670029964128100746510232539453211798711,
 p = 10307593182692464771859444251060107096737374203269378602523841560237645162159897774629661654952776237523790091862810352641745767095280638930754828620479591]
 ```

and from here we can just RSA decrypt the flag.

```py
from Crypto.Util.number import *
q = 8128979845892982561867353232387733688040820165501281055994560204992985831326225951788922087412585314864187432126945670029964128100746510232539453211798711
p = 10307593182692464771859444251060107096737374203269378602523841560237645162159897774629661654952776237523790091862810352641745767095280638930754828620479591
n = 83790217241770949930785127822292134633736157973099853931383028198485119939022553589863171712515159590920355561620948287649289302675837892832944404211978967792836179441682795846147312001618564075776280810972021418434978269714364099297666710830717154344277019791039237445921454207967552782769647647208575607201
c = 55170985485931992412061493588380213138061989158987480264288581679930785576529127257790549531229734149688212171710561151529495719876972293968746590202214939126736042529012383384602168155329599794302309463019364103314820346709676184132071708770466649702573831970710420398772142142828226424536566463017178086577
d = pow(65537, -1, (p-1)*(q-1))
long_to_bytes(pow(c, d, n))
```

giving `amateursCTF{harder_than_3_operations?!?!!}`