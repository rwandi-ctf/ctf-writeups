# Weak Primes

category: crypto

author: `hellopir2`

> I know having p and q be too close together is insecure, but surely my innovative prime generation method is secure. I can't see why it isn't.

We are given `main.py`:

```py
from Crypto.Util.number import *
from flag import flag


def phi(p, q):
    if p == q:
        return (p-1)*p
    else:
        return (p-1)*(q-1)


def getModPrime(modulus):
    p = 2**2047 + getPrime(128)
    p += (modulus - p) % modulus
    p += 1
    iters = 0
    while not isPrime(p):
        p += modulus
    return p


flag = bytes_to_long(flag)
p = getPrime(2048)
q = getModPrime(3)

n = p*q
e = 65537
d = inverse(e, phi(p, q))
c = pow(flag, e, n)

with open('output.txt', 'w') as f:
    f.write(f"{c} {e} {n}")
```

and its `output.txt`:

```
370166700119554563326700293524870319704004763256654262119894449104706176772874482044402534354559483925810678750583295040186009492862602699249928877036138356553701321228911532381166315117219451599252646161037443638677773448335452169454184649126128208160839615812473681964949474260681309407252497983911530065458322024342070488989834634744554553751033744442777133562880006728695949784378016605501827217487891764858287974975497868476575761808245767776419920653953943909308645219641148059781842549965985460978962674762904340291540963049348315329402682400992061198248164015281139306740473382515823687902194975478278593148943757499949255234839146084048527531039260094417699007944944122181935268581856451893221820787751822253439218792553696260823026812050825184840860779046115894361497044311272212790121893548744564723733339277410520826062844634954480681842402878348394438604008614174962876689774679873193780393514977795415573386873676590322006096014650078099815961622336723988030735004604126330212815079730101246670281603951594454668164446498101094689398208813138108422626474329070881671406846037837730035440159781831683646567880537450109406848708245074512984459160782275457249994037411392698600939900612767527630736567146219710727262081623 65537 488083532976806084089590477650626358470267060858394130451148014373367242346498608604784613672466909744405459996701984874902955111433679557998635407906878296412067657643904347220463283351362773552751246978077607274145216766545334655548335243712504971716138541137454923418304262722579453503449234943348691033739760475012650728352613028889060355085613061376621942987579754489473480874291539369825016326661019284241520360792002006326580105031556454952959640078682204619119729574400061326916057641853577938962487454572519350659514324945732686868774674946365102130469452130033035796316169837699269465537987386869865246752685777927363998402066435424632408996419501583426553054881545182912748760954659462455734639982442899206639796709805940097444836946542004332363987031978153519279001467795138259248718051692059040739727006813965459458202249823771317542184355133379219308132437177929292011842722331881982132474574412500388535472801822716396916941397653526803129946808695287381941625310393079973085400552213748099067456069854483862307767583161308731242484789357307718063256524501566737965977742241951466168215921734615657708316837781312209557746470448353745855456531626738664181479391533445614906943592551197517774670399668293723760785168301
```

This is RSA with public key $n=pq$, but this time the way $q$ is generated is quite sus.

```py
def getModPrime(modulus):
    p = 2**2047 + getPrime(128)
    p += (modulus - p) % modulus
    p += 1
    iters = 0
    while not isPrime(p):
        p += modulus
    return p
```

$q$ is generated from this function with a modulus of 3.
Essentially, it starts with $2^{2047}$, then adds a 128 bit prime and then small values until hitting a prime value.

The hint says that $p$ and $q$ are close to each other, but thats not particularly true here since $p$ is an actual random 2048-bit prime. But what is true is that $q$ is extremely close to $2^{2047}$, being only around $2^{128}$ above it.

So, whats the RSA vulnerability when we have a really good approximation for one of the primes? Coppersmith's attack.

The coppersmith method uses lattice reduction to find small integer solutions to a polynomial modulo a factor of $n$ that is $\ge n^\beta$

Setting $\beta \approx 0.5$ and $f(x)=2^{2047}+x$, it will find an integer solution to $x$ such that $2^{2047}+x \equiv 0 \pmod m$ where $m \mid n, m \ge n^\beta$, which is precisely what we want.

(the smaller the difference between $m$ and $n^\beta$ the better, so set $\beta$ to just under $0.5$)

The coppersmith method is implemented within sage's `small_roots` function, so we can just use that:

```py
# sage
c = 370166700119554563326700293524870319704004763256654262119894449104706176772874482044402534354559483925810678750583295040186009492862602699249928877036138356553701321228911532381166315117219451599252646161037443638677773448335452169454184649126128208160839615812473681964949474260681309407252497983911530065458322024342070488989834634744554553751033744442777133562880006728695949784378016605501827217487891764858287974975497868476575761808245767776419920653953943909308645219641148059781842549965985460978962674762904340291540963049348315329402682400992061198248164015281139306740473382515823687902194975478278593148943757499949255234839146084048527531039260094417699007944944122181935268581856451893221820787751822253439218792553696260823026812050825184840860779046115894361497044311272212790121893548744564723733339277410520826062844634954480681842402878348394438604008614174962876689774679873193780393514977795415573386873676590322006096014650078099815961622336723988030735004604126330212815079730101246670281603951594454668164446498101094689398208813138108422626474329070881671406846037837730035440159781831683646567880537450109406848708245074512984459160782275457249994037411392698600939900612767527630736567146219710727262081623
n = 488083532976806084089590477650626358470267060858394130451148014373367242346498608604784613672466909744405459996701984874902955111433679557998635407906878296412067657643904347220463283351362773552751246978077607274145216766545334655548335243712504971716138541137454923418304262722579453503449234943348691033739760475012650728352613028889060355085613061376621942987579754489473480874291539369825016326661019284241520360792002006326580105031556454952959640078682204619119729574400061326916057641853577938962487454572519350659514324945732686868774674946365102130469452130033035796316169837699269465537987386869865246752685777927363998402066435424632408996419501583426553054881545182912748760954659462455734639982442899206639796709805940097444836946542004332363987031978153519279001467795138259248718051692059040739727006813965459458202249823771317542184355133379219308132437177929292011842722331881982132474574412500388535472801822716396916941397653526803129946808695287381941625310393079973085400552213748099067456069854483862307767583161308731242484789357307718063256524501566737965977742241951466168215921734615657708316837781312209557746470448353745855456531626738664181479391533445614906943592551197517774670399668293723760785168301
P.<x> = Zmod(n)[]
f = x + 2**2047
p = f.small_roots()[0]
# [488083532976806084089590477650626358470267060858394130451148014373367242346498608604784613672466909744405459996701984874902955111433679557998635407906878296412067657643904347220463283351362773552751246978077607274145216766545334655548335243712504971716138541137454923418304262722579453503449234943348691033739760475012650728352613028889060355085613061376621942987579754489473480874291539369825016326661019284241520360792002006326580105031556454952959640078682204619119729574400061326916057641853577938962487454572519350659514324945732686868774674946365102130469452130033035796316169837699269465537987386869865246752669619424328342898416077986288074020439279532091695312865480010198986433385225517009136039276681442474795437729344991087697777166966758871816442955784929377718686029111487761202842952816864214686328977994773425674063853714450007664103436086209981222897146355003273859321278543936211599570270636300826570280040865549702082770187311039409847662061267199364278464281354177143419887455859517941992326773422395303944795781302077802563685613781156895111054675694950094350364179399596056063353343183752192046581998510021881208778947449719569356137423864155469462811619732377898292141269891958215298596302890366918230987052973]
```
and it instantly found a solution. Now, we just sub it back into $f$ to get one of the prime factors and can decrypt the flag manually.

```py
# sage
P.<x> = Zmod(n)[]
f = x + 2**2047
p = int(f.small_roots(beta=0.49)[0] + 2**2047)
q = n//p
d = pow(0x10001, -1, (p-1)*(q-1))
long_to_bytes(pow(c, d, n))
```
giving `b"amateursCTF{wH4t's_4_pR1m3?}"`